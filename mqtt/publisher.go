package mqtt

import (
	"encoding/json"
	"fmt"
	"os"
	"time"

	mqttclient "github.com/eclipse/paho.mqtt.golang"
	"github.com/koesie10/ws-upload/wsupload"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var _ wsupload.Publisher = (*publisher)(nil)

type publisher struct {
	client mqttclient.Client
	logger *zap.Logger

	options PublisherOptions

	done chan struct{}
}

func NewPublisher(logger *zap.Logger, options PublisherOptions) (wsupload.Publisher, error) {
	if logger == nil {
		logger = zap.NewNop()
	}

	if options.Debug {
		setupDebugLogs(logger.With(zap.String("component", "mqtt")))
	}

	hostname, _ := os.Hostname()

	if options.ClientID == "" {
		options.ClientID = fmt.Sprintf("%s-%d", hostname, time.Now().Unix())
	}

	connOpts := mqttclient.NewClientOptions().SetClientID(options.ClientID).SetCleanSession(true)

	for _, broker := range options.Brokers {
		connOpts.AddBroker(broker)
	}

	if options.Username != "" {
		connOpts.SetUsername(options.Username)
		if options.Password != "" {
			connOpts.SetPassword(options.Password)
		}
	}
	connOpts.SetAutoReconnect(true)
	connOpts.SetConnectRetry(true)

	client := mqttclient.NewClient(connOpts)

	p := &publisher{
		client:  client,
		logger:  logger,
		options: options,

		done: make(chan struct{}),
	}

	go p.watchdog()

	return p, nil
}

type PublisherOptions struct {
	Brokers  []string `env:"MQTT_BROKERS" flag:"brokers" desc:"MQTT broker addresses, leave empty to disable"`
	ClientID string   `env:"MQTT_CLIENT_ID" flag:"client-id" desc:"MQTT client ID, default will be autogenerated based on the client hostname"`
	Username string   `env:"MQTT_USERNAME" flag:"username" desc:"MQTT username"`
	Password string   `env:"MQTT_PASSWORD" flag:"password" desc:"MQTT password"`

	Topic string `env:"MQTT_TOPIC" flag:"topic" desc:"topic to publish to"`
	QoS   int    `env:"MQTT_QOS" flag:"qos" desc:"the QoS to send the messages at"`

	HomeAssistant HomeAssistantOptions `env:",squash"`

	Debug bool `env:"MQTT_DEBUG" flag:"debug" desc:"whether to enable debug logging"`
}

type HomeAssistantOptions struct {
	DiscoveryEnabled  bool          `env:"MQTT_HOMEASSISTANT_DISCOVERY_ENABLED" flag:"discovery-enabled" desc:"whether HomeAssistant MQTT discovery is enabled"`
	DiscoveryPrefix   string        `env:"MQTT_HOMEASSISTANT_DISCOVERY_PREFIX" flag:"discovery-prefix" desc:"HomeAssistant MQTT discovery prefix"`
	DiscoveryQoS      int           `env:"MQTT_HOMEASSISTANT_DISCOVERY_QOS" flag:"discovery-qos" desc:"HomeAssistant MQTT discovery QoS"`
	DiscoveryInterval time.Duration `env:"MQTT_HOMEASSISTANT_DISCOVERY_INTERVAL" flag:"discovery-interval" desc:"HomeAssistant MQTT discovery interval"`
	DevicePrefix      string        `env:"MQTT_HOMEASSISTANT_DEVICE_PREFIX" flag:"device-prefix" desc:"HomeAssistant device prefix"`

	UniqueIDPrefix     string   `env:"MQTT_HOMEASSISTANT_UNIQUE_ID_PREFIX" flag:"unique-id" desc:"HomeAssistant unique ID prefix"`
	DeviceIdentifiers  []string `env:"MQTT_HOMEASSISTANT_DEVICE_IDENTIFIERS" flag:"device-identifiers" desc:"HomeAssistant identifiers"`
	DeviceManufacturer string   `env:"MQTT_HOMEASSISTANT_DEVICE_MANUFACTURER" flag:"device-manufacturer" desc:"HomeAssistant manufacturer"`
	DeviceModel        string   `env:"MQTT_HOMEASSISTANT_DEVICE_MODEL" flag:"device-model" desc:"HomeAssistant model"`
	DeviceName         string   `env:"MQTT_HOMEASSISTANT_DEVICE_NAME" flag:"device-name" desc:"HomeAssistant name"`
}

func (p *publisher) Publish(obs *wsupload.Observation) error {
	data, err := json.Marshal(obs)
	if err != nil {
		return fmt.Errorf("failed to marshal observation to JSON: %w", err)
	}

	token := p.client.Publish(p.options.Topic, byte(p.options.QoS), true, string(data))
	go func() {
		token.Wait()
		if err := token.Error(); err != nil {
			p.logger.Warn("Failed to publish observation to MQTT", zap.Error(err))
		}
	}()

	return nil
}

func (p *publisher) Close() error {
	close(p.done)

	return nil
}

func (p *publisher) watchdog() {
	token := p.client.Connect()

	token.Wait()

	if token.Error() != nil {
		p.logger.Error("Failed to connect to MQTT broker", zap.Error(token.Error()))
	}

	discoveryInterval := p.options.HomeAssistant.DiscoveryInterval
	if discoveryInterval == 0 {
		discoveryInterval = 30 * time.Second
	}

	t := time.NewTicker(discoveryInterval)
	defer t.Stop()

	p.logger.Info("Connected to MQTT broker")

	if err := p.publishDiscovery(); err != nil {
		p.logger.Warn("Failed to publish discovery message", zap.Error(err))
	}

	for {
		select {
		case <-p.done:
			p.client.Disconnect(250)

			return
		case <-t.C:
			if err := p.publishDiscovery(); err != nil {
				p.logger.Warn("Failed to publish discovery message", zap.Error(err))
			}
		}
	}
}

func setupDebugLogs(baseLogger *zap.Logger) {
	mqttclient.DEBUG = &logger{
		level: zapcore.DebugLevel,
		entry: baseLogger,
	}
	mqttclient.WARN = &logger{
		level: zapcore.InfoLevel,
		entry: baseLogger,
	}
	mqttclient.ERROR = &logger{
		level: zapcore.WarnLevel,
		entry: baseLogger,
	}
	mqttclient.CRITICAL = &logger{
		level: zapcore.ErrorLevel,
		entry: baseLogger,
	}
}

type logger struct {
	level zapcore.Level
	entry *zap.Logger
}

func (l *logger) Println(v ...interface{}) {
	l.entry.Check(l.level, fmt.Sprintf("%v", v)).Write()
}

func (l *logger) Printf(format string, v ...interface{}) {
	l.entry.Check(l.level, fmt.Sprintf(format, v...)).Write()
}

package mqtt

import (
	"fmt"
	"os"
	"time"

	mqttclient "github.com/eclipse/paho.mqtt.golang"
	"github.com/koesie10/ws-upload/wsupload"
	"github.com/sirupsen/logrus"
)

var _ wsupload.Publisher = (*publisher)(nil)

type publisher struct {
	client mqttclient.Client

	options PublisherOptions

	done chan struct{}
}

func NewPublisher(options PublisherOptions) (wsupload.Publisher, error) {
	hostname, _ := os.Hostname()

	if options.ClientID == "" {
		options.ClientID = fmt.Sprintf("%s-%d", hostname, time.Now().Unix())
	}

	connOpts := mqttclient.NewClientOptions().SetClientID(options.ClientID).SetCleanSession(true)

	for _, broker := range options.Brokers {
		connOpts.AddBroker(broker)
	}

	if options.Username != "" {
		connOpts.SetUsername(options.Username)
		if options.Password != "" {
			connOpts.SetPassword(options.Password)
		}
	}
	connOpts.SetAutoReconnect(true)
	connOpts.SetConnectRetry(true)

	client := mqttclient.NewClient(connOpts)

	p := &publisher{
		client:  client,
		options: options,

		done: make(chan struct{}),
	}

	go p.watchdog()

	return p, nil
}

type PublisherOptions struct {
	Brokers  []string `env:"MQTT_BROKERS" flag:"brokers" desc:"MQTT broker addresses, leave empty to disable"`
	ClientID string   `env:"MQTT_CLIENT_ID" flag:"client-id" desc:"MQTT client ID, default will be autogenerated based on the client hostname"`
	Username string   `env:"MQTT_USERNAME" flag:"username" desc:"MQTT username"`
	Password string   `env:"MQTT_PASSWORD" flag:"password" desc:"MQTT password"`
}

func (p *publisher) Publish(obs *wsupload.Observation) error {
	return nil
}

func (p *publisher) Close() error {
	close(p.done)

	return nil
}

func (p *publisher) watchdog() {
	token := p.client.Connect()

	token.Wait()

	if token.Error() != nil {
		logrus.WithError(token.Error()).Errorf("Failed to connect to MQTT broker")
	}

	logrus.Infof("Connected to MQTT broker")

	select {
	case <-p.done:
		p.client.Disconnect(250)

		return
	}
}

func init() {
	mqttclient.DEBUG = &logger{
		level: logrus.TraceLevel,
		entry: logrus.WithField("system", "mqtt"),
	}
	mqttclient.WARN = &logger{
		level: logrus.InfoLevel,
		entry: logrus.WithField("system", "mqtt"),
	}
	mqttclient.ERROR = &logger{
		level: logrus.WarnLevel,
		entry: logrus.WithField("system", "mqtt"),
	}
	mqttclient.CRITICAL = &logger{
		level: logrus.ErrorLevel,
		entry: logrus.WithField("system", "mqtt"),
	}
}

type logger struct {
	level logrus.Level
	entry *logrus.Entry
}

func (l *logger) Println(v ...interface{}) {
	l.entry.Log(l.level, v...)
}

func (l *logger) Printf(format string, v ...interface{}) {
	l.entry.Logf(l.level, format, v...)
}
